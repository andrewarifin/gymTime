import { BarcodePickerGui } from "./barcodePickerGui";
import { BrowserHelper } from "./browserHelper";
import { Camera } from "./camera";
import { CameraAccess } from "./cameraAccess";
import { CameraManager } from "./cameraManager";
import { CameraSettings } from "./cameraSettings";
import { CustomError } from "./customError";

/**
 * @hidden
 *
 * A barcode picker utility class used to handle camera interaction.
 */
export class BarcodePickerCameraManager extends CameraManager {
  private static readonly cameraAccessTimeoutMs: number = 4000;
  private static readonly cameraMetadataCheckTimeoutMs: number = 4000;
  private static readonly cameraMetadataCheckIntervalMs: number = 50;
  private static readonly getCapabilitiesTimeoutMs: number = 500;
  private static readonly autofocusIntervalMs: number = 1500;
  private static readonly manualToAutofocusResumeTimeoutMs: number = 5000;
  private static readonly manualFocusWaitTimeoutMs: number = 400;

  private readonly triggerFatalError: (error: Error) => void;
  private readonly barcodePickerGui: BarcodePickerGui;
  private readonly postStreamInitializationListener: () => void = this.postStreamInitialization.bind(this);
  private readonly videoTrackUnmuteListener: () => void = this.videoTrackUnmuteRecovery.bind(this);
  private readonly triggerManualFocusListener: () => void = this.triggerManualFocus.bind(this);
  private readonly triggerZoomStartListener: () => void = this.triggerZoomStart.bind(this);
  private readonly triggerZoomMoveListener: () => void = this.triggerZoomMove.bind(this);

  private selectedCamera?: Camera;
  private selectedCameraSettings?: CameraSettings;
  private mediaStream?: MediaStream;
  private mediaTrackCapabilities?: any;
  private cameraAccessTimeout: number;
  private cameraMetadataCheckInterval: number;
  private getCapabilitiesTimeout: number;
  private autofocusInterval: number;
  private manualToAutofocusResumeTimeout: number;
  private manualFocusWaitTimeout: number;
  private cameraSwitcherEnabled: boolean;
  private torchToggleEnabled: boolean;
  private tapToFocusEnabled: boolean;
  private pinchToZoomEnabled: boolean;
  private pinchToZoomDistance?: number;
  private pinchToZoomInitialZoom: number;
  private torchEnabled: boolean;
  private cameraInitializationPromise?: Promise<void>;

  constructor(triggerFatalError: (error: Error) => void, barcodePickerGui: BarcodePickerGui) {
    super();
    this.triggerFatalError = triggerFatalError;
    this.barcodePickerGui = barcodePickerGui;
  }

  public setInteractionOptions(
    cameraSwitcherEnabled: boolean,
    torchToggleEnabled: boolean,
    tapToFocusEnabled: boolean,
    pinchToZoomEnabled: boolean
  ): void {
    this.cameraSwitcherEnabled = cameraSwitcherEnabled;
    this.torchToggleEnabled = torchToggleEnabled;
    this.tapToFocusEnabled = tapToFocusEnabled;
    this.pinchToZoomEnabled = pinchToZoomEnabled;
  }

  public isCameraSwitcherEnabled(): boolean {
    return this.cameraSwitcherEnabled;
  }

  public setCameraSwitcherEnabled(enabled: boolean): void {
    this.cameraSwitcherEnabled = enabled;

    if (this.cameraSwitcherEnabled) {
      CameraAccess.getCameras().then(cameras => {
        if (cameras.length > 1) {
          this.barcodePickerGui.setCameraSwitcherVisible(true);
        }
      });
    } else {
      this.barcodePickerGui.setCameraSwitcherVisible(false);
    }
  }

  public isTorchToggleEnabled(): boolean {
    return this.torchToggleEnabled;
  }

  public setTorchToggleEnabled(enabled: boolean): void {
    this.torchToggleEnabled = enabled;

    if (this.torchToggleEnabled) {
      if (this.mediaStream != null && this.mediaTrackCapabilities != null && this.mediaTrackCapabilities.torch) {
        this.barcodePickerGui.setTorchTogglerVisible(true);
      }
    } else {
      this.barcodePickerGui.setTorchTogglerVisible(false);
    }
  }

  public isTapToFocusEnabled(): boolean {
    return this.tapToFocusEnabled;
  }

  public setTapToFocusEnabled(enabled: boolean): void {
    this.tapToFocusEnabled = enabled;

    if (this.mediaStream != null) {
      if (this.tapToFocusEnabled) {
        this.enableTapToFocusListeners();
      } else {
        this.disableTapToFocusListeners();
      }
    }
  }

  public isPinchToZoomEnabled(): boolean {
    return this.pinchToZoomEnabled;
  }

  public setPinchToZoomEnabled(enabled: boolean): void {
    this.pinchToZoomEnabled = enabled;

    if (this.mediaStream != null) {
      if (this.pinchToZoomEnabled) {
        this.enablePinchToZoomListeners();
      } else {
        this.disablePinchToZoomListeners();
      }
    }
  }

  public setSelectedCamera(camera?: Camera): void {
    this.selectedCamera = camera;
  }

  public setSelectedCameraSettings(cameraSettings?: CameraSettings): void {
    this.selectedCameraSettings = cameraSettings;
  }

  public setupCameras(): Promise<void> {
    if (this.cameraInitializationPromise != null) {
      return this.cameraInitializationPromise;
    }

    return CameraAccess.getCameras().then(cameras => {
      if (this.cameraSwitcherEnabled && cameras.length > 1) {
        this.barcodePickerGui.setCameraSwitcherVisible(true);
      }

      if (this.selectedCamera == null) {
        let autoselectedCamera: Camera | undefined = cameras.find(currentCamera => {
          return currentCamera.cameraType === Camera.Type.BACK;
        });
        if (autoselectedCamera === undefined) {
          autoselectedCamera = cameras[0];
        }
        if (autoselectedCamera === undefined) {
          return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
        }

        return this.initializeCameraWithSettings(autoselectedCamera, this.selectedCameraSettings);
      } else {
        return this.initializeCameraWithSettings(this.selectedCamera, this.selectedCameraSettings);
      }
    });
  }

  public stopStream(): void {
    if (this.activeCamera != null) {
      this.activeCamera.currentResolution = undefined;
    }

    this.activeCamera = undefined;

    if (this.mediaStream != null) {
      window.clearTimeout(this.cameraAccessTimeout);
      window.clearInterval(this.cameraMetadataCheckInterval);
      window.clearTimeout(this.getCapabilitiesTimeout);
      window.clearTimeout(this.manualFocusWaitTimeout);
      window.clearTimeout(this.manualToAutofocusResumeTimeout);
      window.clearInterval(this.autofocusInterval);
      this.mediaStream.getVideoTracks().forEach(track => {
        track.stop();
      });
      this.mediaStream = undefined;
      this.mediaTrackCapabilities = undefined;
    }
  }

  public applyCameraSettings(cameraSettings?: CameraSettings): Promise<void> {
    this.selectedCameraSettings = cameraSettings;

    if (this.activeCamera == null) {
      return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
    }

    return this.initializeCameraWithSettings(this.activeCamera, cameraSettings);
  }

  public reinitializeCamera(camera?: Camera): Promise<void> {
    if (this.activeCamera == null && camera == null) {
      return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
    }

    return this.initializeCameraWithSettings(
      camera == null ? <Camera>this.activeCamera : camera,
      this.activeCameraSettings
    ).catch(this.triggerFatalError);
  }

  public initializeCameraWithSettings(camera: Camera, cameraSettings?: CameraSettings): Promise<void> {
    let existingCameraInitializationPromise: Promise<void> = Promise.resolve();
    if (this.cameraInitializationPromise != null) {
      existingCameraInitializationPromise = this.cameraInitializationPromise;
    }

    return existingCameraInitializationPromise.then(() => {
      this.selectedCamera = camera;
      this.selectedCameraSettings = this.activeCameraSettings = cameraSettings;
      if (
        cameraSettings != null &&
        cameraSettings.resolutionPreference === CameraSettings.ResolutionPreference.FULL_HD
      ) {
        this.cameraInitializationPromise = this.initializeCameraAndCheckUpdatedSettings(camera);
      } else {
        this.cameraInitializationPromise = this.initializeCameraAndCheckUpdatedSettings(camera, 3);
      }

      return this.cameraInitializationPromise;
    });
  }

  public setTorchEnabled(enabled: boolean): void {
    if (this.mediaStream != null && this.mediaTrackCapabilities != null && this.mediaTrackCapabilities.torch) {
      this.torchEnabled = enabled;
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].applyConstraints === "function") {
        videoTracks[0].applyConstraints({ advanced: [<any>{ torch: enabled }] });
      }
    }
  }

  public toggleTorch(): void {
    this.torchEnabled = !this.torchEnabled;
    this.setTorchEnabled(this.torchEnabled);
  }

  public setZoom(zoomPercentage: number, currentZoom?: number): void {
    if (this.mediaStream != null && this.mediaTrackCapabilities != null && this.mediaTrackCapabilities.zoom) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].applyConstraints === "function") {
        const zoomRange: number = this.mediaTrackCapabilities.zoom.max - this.mediaTrackCapabilities.zoom.min;
        if (currentZoom == null) {
          currentZoom = <number>this.mediaTrackCapabilities.zoom.min;
        }
        const targetZoom: number = Math.max(
          this.mediaTrackCapabilities.zoom.min,
          Math.min(currentZoom + zoomRange * zoomPercentage, this.mediaTrackCapabilities.zoom.max)
        );
        videoTracks[0].applyConstraints({ advanced: [<any>{ zoom: targetZoom }] });
      }
    }
  }

  private postStreamInitialization(): void {
    window.clearTimeout(this.getCapabilitiesTimeout);
    this.getCapabilitiesTimeout = window.setTimeout(() => {
      this.storeStreamCapabilities();
      this.setupAutofocus();
      if (
        this.torchToggleEnabled &&
        this.mediaStream != null &&
        this.mediaTrackCapabilities != null &&
        this.mediaTrackCapabilities.torch
      ) {
        this.barcodePickerGui.setTorchTogglerVisible(true);
      }
    }, BarcodePickerCameraManager.getCapabilitiesTimeoutMs);
  }

  private videoTrackUnmuteRecovery(): void {
    this.reinitializeCamera();
  }

  private triggerManualFocus(event?: MouseEvent | TouchEvent): void {
    if (event != null) {
      event.preventDefault();
      if (event.type === "touchend" && (<TouchEvent>event).touches.length !== 0) {
        return;
      }
      // Check if we were using pinch-to-zoom
      if (this.pinchToZoomDistance != null) {
        this.pinchToZoomDistance = undefined;

        return;
      }
    }
    window.clearTimeout(this.manualFocusWaitTimeout);
    window.clearTimeout(this.manualToAutofocusResumeTimeout);
    if (this.mediaStream != null && this.mediaTrackCapabilities != null) {
      const focusModeCapability: string[] = this.mediaTrackCapabilities.focusMode;
      if (focusModeCapability instanceof Array && focusModeCapability.indexOf("single-shot") !== -1) {
        if (focusModeCapability.indexOf("continuous") !== -1 && focusModeCapability.indexOf("manual") !== -1) {
          this.triggerFocusMode("continuous")
            .then(() => {
              this.manualFocusWaitTimeout = window.setTimeout(() => {
                this.triggerFocusMode("manual");
              }, BarcodePickerCameraManager.manualFocusWaitTimeoutMs);
            })
            .catch(() => {
              // Ignored
            });

          this.manualToAutofocusResumeTimeout = window.setTimeout(() => {
            this.triggerFocusMode("continuous");
          }, BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs);
        } else if (focusModeCapability.indexOf("continuous") === -1) {
          window.clearInterval(this.autofocusInterval);

          this.triggerFocusMode("single-shot").catch(() => {
            // Ignored
          });

          this.manualToAutofocusResumeTimeout = window.setTimeout(() => {
            this.autofocusInterval = window.setInterval(
              this.triggerAutoFocus.bind(this),
              BarcodePickerCameraManager.autofocusIntervalMs
            );
          }, BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs);
        }
      }
    }
  }

  private triggerZoomStart(event?: TouchEvent): void {
    if (event == null || event.touches.length !== 2) {
      return;
    }
    event.preventDefault();
    this.pinchToZoomDistance = Math.hypot(
      (event.touches[1].screenX - event.touches[0].screenX) / screen.width,
      (event.touches[1].screenY - event.touches[0].screenY) / screen.height
    );
    if (this.mediaStream != null && this.mediaTrackCapabilities != null && this.mediaTrackCapabilities.zoom) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].getConstraints === "function") {
        this.pinchToZoomInitialZoom = this.mediaTrackCapabilities.zoom.min;
        const currentConstraints: MediaTrackConstraints = videoTracks[0].getConstraints();
        if (currentConstraints.advanced != null) {
          const currentZoomConstraint: MediaTrackConstraintSet | undefined = currentConstraints.advanced.find(
            constraint => {
              return "zoom" in constraint;
            }
          );
          if (currentZoomConstraint != null) {
            this.pinchToZoomInitialZoom = (<any>currentZoomConstraint).zoom;
          }
        }
      }
    }
  }

  private triggerZoomMove(event?: TouchEvent): void {
    if (this.pinchToZoomDistance == null || event == null || event.touches.length !== 2) {
      return;
    }
    event.preventDefault();
    this.setZoom(
      (Math.hypot(
        (event.touches[1].screenX - event.touches[0].screenX) / screen.width,
        (event.touches[1].screenY - event.touches[0].screenY) / screen.height
      ) -
        this.pinchToZoomDistance) *
        2,
      this.pinchToZoomInitialZoom
    );
  }

  private storeStreamCapabilities(): void {
    if (this.mediaStream != null) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].getCapabilities === "function") {
        this.mediaTrackCapabilities = videoTracks[0].getCapabilities();
      }
    }
  }

  private setupAutofocus(): void {
    window.clearTimeout(this.manualFocusWaitTimeout);
    window.clearTimeout(this.manualToAutofocusResumeTimeout);
    if (this.mediaStream != null && this.mediaTrackCapabilities != null) {
      const focusModeCapability: string[] = this.mediaTrackCapabilities.focusMode;
      if (
        focusModeCapability instanceof Array &&
        focusModeCapability.indexOf("continuous") === -1 &&
        focusModeCapability.indexOf("single-shot") !== -1
      ) {
        window.clearInterval(this.autofocusInterval);
        this.autofocusInterval = window.setInterval(
          this.triggerAutoFocus.bind(this),
          BarcodePickerCameraManager.autofocusIntervalMs
        );
      }
    }
  }

  private triggerAutoFocus(): void {
    this.triggerFocusMode("single-shot").catch(() => {
      // Ignored
    });
  }

  private triggerFocusMode(focusMode: string): Promise<void> {
    if (this.mediaStream != null) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].applyConstraints === "function") {
        return videoTracks[0].applyConstraints({ advanced: [<any>{ focusMode }] });
      }
    }

    return Promise.reject(undefined);
  }

  private enableTapToFocusListeners(): void {
    ["touchend", "mousedown"].forEach(eventName => {
      this.barcodePickerGui.videoElement.addEventListener(eventName, this.triggerManualFocusListener);
    });
  }

  private enablePinchToZoomListeners(): void {
    this.barcodePickerGui.videoElement.addEventListener("touchstart", this.triggerZoomStartListener);
    this.barcodePickerGui.videoElement.addEventListener("touchmove", this.triggerZoomMoveListener);
  }

  private disableTapToFocusListeners(): void {
    ["touchend", "mousedown"].forEach(eventName => {
      this.barcodePickerGui.videoElement.removeEventListener(eventName, this.triggerManualFocusListener);
    });
  }

  private disablePinchToZoomListeners(): void {
    this.barcodePickerGui.videoElement.removeEventListener("touchstart", this.triggerZoomStartListener);
    this.barcodePickerGui.videoElement.removeEventListener("touchmove", this.triggerZoomMoveListener);
  }

  private initializeCameraAndCheckUpdatedSettings(camera: Camera, resolutionFallbackLevel?: number): Promise<void> {
    return this.initializeCamera(camera, resolutionFallbackLevel)
      .then(() => {
        // Check if due to asynchronous behaviour camera settings were changed while camera was initialized
        if (
          this.selectedCameraSettings !== this.activeCameraSettings &&
          (this.selectedCameraSettings == null ||
            this.activeCameraSettings == null ||
            Object.keys(this.selectedCameraSettings).some(cameraSettingsProperty => {
              return (
                (<any>this.selectedCameraSettings)[cameraSettingsProperty] !==
                (<any>this.activeCameraSettings)[cameraSettingsProperty]
              );
            }))
        ) {
          this.activeCameraSettings = this.selectedCameraSettings;

          return this.initializeCameraAndCheckUpdatedSettings(camera, resolutionFallbackLevel);
        }

        this.cameraInitializationPromise = undefined;

        return Promise.resolve();
      })
      .catch(error => {
        this.cameraInitializationPromise = undefined;

        return Promise.reject(error);
      });
  }

  private retryInitializeCameraIfNeeded(
    camera: Camera,
    resolutionFallbackLevel: number,
    resolve: (value?: void | PromiseLike<void> | undefined) => void,
    reject: (reason?: any) => void,
    error: Error
  ): Promise<void> | void {
    if (resolutionFallbackLevel < 6) {
      return this.initializeCamera(camera, resolutionFallbackLevel + 1)
        .then(resolve)
        .catch(reject);
    } else {
      return reject(error);
    }
  }

  private initializeCamera(camera: Camera, resolutionFallbackLevel: number = 0): Promise<void> {
    if (camera == null) {
      return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
    }
    this.stopStream();
    this.torchEnabled = false;
    this.barcodePickerGui.setTorchTogglerVisible(false);

    return new Promise((resolve, reject) => {
      CameraAccess.accessCameraStream(resolutionFallbackLevel, camera)
        .then(stream => {
          // Detect weird browser behaviour that on unsupported resolution returns a 2x2 video instead
          if (typeof stream.getTracks()[0].getSettings === "function") {
            const mediaTrackSettings: MediaTrackSettings = stream.getTracks()[0].getSettings();
            if (
              mediaTrackSettings.width != null &&
              mediaTrackSettings.height != null &&
              (mediaTrackSettings.width === 2 || mediaTrackSettings.height === 2)
            ) {
              if (resolutionFallbackLevel === 6) {
                return reject(
                  new CustomError({ name: "NotReadableError", message: "Could not initialize camera correctly" })
                );
              } else {
                return this.initializeCamera(camera, resolutionFallbackLevel + 1)
                  .then(resolve)
                  .catch(reject);
              }
            }
          }
          this.mediaStream = stream;
          this.mediaStream.getVideoTracks().forEach(track => {
            // Reinitialize camera on weird pause/resumption coming from the OS
            // This will add the listener only once in the case of multiple calls, identical listeners are ignored
            track.addEventListener("unmute", this.videoTrackUnmuteListener);
          });
          // This will add the listener only once in the case of multiple calls, identical listeners are ignored
          this.barcodePickerGui.videoElement.addEventListener("loadedmetadata", this.postStreamInitializationListener);
          if (this.tapToFocusEnabled) {
            this.enableTapToFocusListeners();
          }
          if (this.pinchToZoomEnabled) {
            this.enablePinchToZoomListeners();
          }
          this.resolveInitializeCamera(camera, resolve, reject);
          this.barcodePickerGui.videoElement.srcObject = stream;
          this.barcodePickerGui.videoElement.load();
          const playPromise: Promise<void> = this.barcodePickerGui.videoElement.play();
          if (playPromise != null) {
            playPromise.catch(() => {
              // Can sometimes cause an incorrect rejection (all is good, ignore).
            });
          }
        })
        .catch(error => {
          if (error.name === "SourceUnavailableError") {
            error.name = "NotReadableError";
          }
          if (
            error.message === "Invalid constraint" ||
            (error.name === "OverconstrainedError" && error.constraint === "deviceId")
          ) {
            // Camera might have changed deviceId: check for new cameras with same label and type but different deviceId
            return CameraAccess.getCameras().then(cameras => {
              const newCamera: Camera | undefined = cameras.find(currentCamera => {
                return (
                  currentCamera.label === camera.label &&
                  currentCamera.cameraType === camera.cameraType &&
                  currentCamera.deviceId !== camera.deviceId
                );
              });
              if (newCamera == null) {
                return this.retryInitializeCameraIfNeeded(camera, resolutionFallbackLevel, resolve, reject, error);
              } else {
                return this.initializeCamera(newCamera, resolutionFallbackLevel)
                  .then(resolve)
                  .catch(reject);
              }
            });
          }
          if (
            error.name === "PermissionDeniedError" ||
            error.name === "PermissionDismissedError" ||
            error.name === "NotAllowedError" ||
            error.name === "NotFoundError" ||
            error.name === "AbortError"
          ) {
            // Camera is not accessible at all
            return reject(error);
          }

          return this.retryInitializeCameraIfNeeded(camera, resolutionFallbackLevel, resolve, reject, error);
        });
    });
  }

  private resolveInitializeCamera(camera: Camera, resolve: () => void, reject: (reason: Error) => void): void {
    const cameraNotReadableError: Error = new CustomError({
      name: "NotReadableError",
      message: "Could not initialize camera correctly"
    });

    window.clearTimeout(this.cameraAccessTimeout);
    this.cameraAccessTimeout = window.setTimeout(() => {
      this.stopStream();
      reject(cameraNotReadableError);
    }, BarcodePickerCameraManager.cameraAccessTimeoutMs);

    if (BrowserHelper.userAgentInfo.getOS().name === "iOS") {
      // iOS camera access should always work but can fail to call "later" video callbacks, so we check loadstart
      this.barcodePickerGui.videoElement.onloadstart = () => {
        (<any>this.barcodePickerGui.videoElement).onloadstart = null;
        window.clearTimeout(this.cameraAccessTimeout);

        this.activeCamera = camera;
        this.barcodePickerGui.videoElement.dispatchEvent(new Event("canplay"));

        resolve();
      };
    } else {
      this.barcodePickerGui.videoElement.onloadeddata = () => {
        this.barcodePickerGui.videoElement.onloadeddata = null;
        window.clearTimeout(this.cameraAccessTimeout);

        // Detect weird browser behaviour that on unsupported resolution returns a 2x2 video instead
        // Also detect failed camera access with no error but also no video stream provided
        if (
          this.barcodePickerGui.videoElement.videoWidth > 2 &&
          this.barcodePickerGui.videoElement.videoHeight > 2 &&
          this.barcodePickerGui.videoElement.currentTime > 0
        ) {
          this.activeCamera = camera;
          this.barcodePickerGui.videoElement.dispatchEvent(new Event("canplay"));

          return resolve();
        }

        const cameraMetadataCheckStartTime: number = performance.now();

        window.clearInterval(this.cameraMetadataCheckInterval);
        this.cameraMetadataCheckInterval = window.setInterval(() => {
          if (
            this.barcodePickerGui.videoElement.videoWidth === 2 ||
            this.barcodePickerGui.videoElement.videoHeight === 2 ||
            this.barcodePickerGui.videoElement.currentTime === 0
          ) {
            if (
              performance.now() - cameraMetadataCheckStartTime >
              BarcodePickerCameraManager.cameraMetadataCheckTimeoutMs
            ) {
              window.clearInterval(this.cameraMetadataCheckInterval);
              this.stopStream();

              return reject(cameraNotReadableError);
            }

            return;
          }

          window.clearInterval(this.cameraMetadataCheckInterval);
          this.activeCamera = camera;
          this.barcodePickerGui.videoElement.dispatchEvent(new Event("canplay"));

          return resolve();
        }, BarcodePickerCameraManager.cameraMetadataCheckIntervalMs);
      };
    }
  }
}
