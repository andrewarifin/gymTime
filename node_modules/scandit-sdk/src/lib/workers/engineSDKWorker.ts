// tslint:disable:no-string-literal
import { ImageSettings } from "../imageSettings";
import { Parser } from "../parser";

// TODO: Find a nice way to use typescript WebWorker lib/types just for worker files
/**
 * @hidden
 */
declare const importScripts: (...urls: string[]) => void;
/**
 * @hidden
 */
declare const postMessage: (message: any, transfer?: any[]) => void;

/**
 * @hidden
 */
type FileSystemType = {};

/**
 * @hidden
 */
declare const Module: {
  HEAPU8: Uint8Array;
  asm: any;
  lengthBytesUTF8(str: string): number;
  UTF8ToString(ptr: number): string;
  stringToUTF8(str: string, outPtr: number, maxBytesToWrite: number): void;
  _malloc(size: number): number;
  _free(ptr: number): void;
  callMain(): void;
};

/**
 * @hidden
 */
declare namespace FS {
  function syncfs(populate: boolean, callback: (e: any) => any): void;
  function syncfs(callback: (e: any) => any, populate?: boolean): void;
  function mount(fsType: FileSystemType, opts: any, mountpoint: string): any;
  function mkdir(path: string, mode?: number): any;
}

/**
 * @hidden
 */
declare const IDBFS: FileSystemType;

/**
 * @hidden
 */
declare type ScanWorkUnit = {
  requestId: number;
  data: Uint8ClampedArray;
  highQualitySingleFrameMode: boolean;
};

/**
 * @hidden
 */
declare type ParseWorkUnit = {
  requestId: number;
  dataFormat: Parser.DataFormat;
  dataString: string;
  options: string;
};

/**
 * @hidden
 */
// tslint:disable-next-line:max-func-body-length
export function engineSDKWorkerFunction(): void {
  let imageBufferPointer: number | undefined;
  let licenseKey: string;
  let settings: string;
  let imageSettings: ImageSettings;
  let wasmLoaded: boolean = false;
  let scannerSettingsReady: boolean = false;
  let scannerImageSettingsReady: boolean = false;
  const scanQueue: ScanWorkUnit[] = [];
  const parseQueue: ParseWorkUnit[] = [];
  let contextAvailable: boolean = false;
  let scanWorkSubmitted: boolean = false;
  let parseWorkSubmitted: boolean = false;
  let blurryDecodingEnabled: boolean = false;

  // Adapted from: https://github.com/mdn/webassembly-examples/blob/master/wasm-utils.js
  function instantiateWasmWithCache(
    wasmURI: string,
    wasmVersion: number,
    importObject: any,
    successCallback: (instance: any) => void
  ): void {
    const dbName: string = "scandit_wasm_cache";
    const storeName: string = "scandit_wasm_cache";
    const key: string = "wasm";
    let db: IDBDatabase;
    function loadDatabase(resolve: (result: any) => void, reject: (result: any) => void): void {
      let openDBRequest: IDBOpenDBRequest;
      try {
        openDBRequest = indexedDB.open(dbName, wasmVersion);
      } catch (error) {
        return reject(`Failed to open scandit-sdk WebAssembly cache database: ${error}`);
      }
      openDBRequest.onerror = () => {
        return reject("Failed to open scandit-sdk WebAssembly cache database");
      };
      openDBRequest.onsuccess = () => {
        db = openDBRequest.result;
        const store: IDBObjectStore = db.transaction([storeName]).objectStore(storeName);
        const request: IDBRequest = store.get(key);
        request.onerror = () => {
          return reject("Failed to open scandit-sdk WebAssembly cache database");
        };
        request.onsuccess = () => {
          if (request.result != null) {
            return resolve(request.result);
          } else {
            return reject("No cached version of the scandit-sdk WebAssembly code has been found");
          }
        };
      };
      openDBRequest.onupgradeneeded = () => {
        db = openDBRequest.result;
        if (db.objectStoreNames.contains(storeName)) {
          db.deleteObjectStore(storeName);
        }
        db.createObjectStore(storeName);
      };
    }
    function storeInDatabase(moduleObject: any): void {
      try {
        const store: IDBObjectStore = db.transaction([storeName], "readwrite").objectStore(storeName);
        const request: IDBRequest = store.put(moduleObject, key);
        request.onerror = error => {
          console.debug(`Failed to cache scandit-sdk WebAssembly code: ${error}`);
        };
        request.onsuccess = () => {
          console.debug("Successfully cached scandit-sdk WebAssembly code");
        };
      } catch (error) {
        if (error.name === "DataCloneError") {
          console.debug("Failed to cache scandit-sdk WebAssembly code: This browser doesn't support this feature yet");
        } else {
          console.debug(`Failed to cache scandit-sdk WebAssembly code: ${error}`);
        }
      }
    }

    loadDatabase(
      moduleObject => {
        console.debug("Found cached scandit-sdk WebAssembly code");
        (<any>self).WebAssembly.instantiate(moduleObject, importObject).then((instance: any) => {
          successCallback(instance);
        });
      },
      errMsg => {
        console.debug(errMsg);
        function instantiate(): void {
          fetch(wasmURI)
            .then(response => response.arrayBuffer())
            .then(bytes => {
              (<any>self).WebAssembly.instantiate(bytes, importObject).then((results: any) => {
                if (db != null) {
                  storeInDatabase(results.module);
                }
                successCallback(results.instance);
              });
            });
        }
        function instantiateStreaming(): void {
          (<any>self).WebAssembly.instantiateStreaming(fetch(wasmURI), importObject)
            .then((results: any) => {
              if (db != null) {
                storeInDatabase(results.module);
              }
              successCallback(results.instance);
            })
            .catch((error: Error) => {
              console.warn(`wasm streaming compile failed: ${error}, falling back to ArrayBuffer instantiation`);
              instantiate();
            });
        }

        if (typeof (<any>self).WebAssembly.instantiateStreaming === "function") {
          instantiateStreaming();
        } else {
          instantiate();
        }
      }
    );
  }

  function loadLibrary(deviceId: string, libraryLocation: string): void {
    const customModule: any = {
      arguments: [deviceId],
      instantiateWasm: (importObject: any, successCallback: (instance: any) => void) => {
        const wasmURI: string = `${libraryLocation}scandit-engine-sdk.wasm?v=%WASM_VERSION%`;
        const wasmVersion: number = "%WASM_VERSION%"
          .split(".")
          .map((n, i) => parseInt(n, 10) * Math.pow(10, 6 - i * 3))
          .reduce((a, b) => a + b);

        instantiateWasmWithCache(wasmURI, wasmVersion, importObject, successCallback);

        return {};
      },
      noInitialRun: true,
      preRun: () => {
        try {
          FS.mkdir("/scandit_sync_folder");
        } catch (error) {
          if (error.code !== "EEXIST") {
            throw error;
          }
        }
        FS.mount(IDBFS, {}, "/scandit_sync_folder");
        FS.syncfs(true, () => {
          Module.callMain();
          wasmLoaded = true;
          postMessage(["status", "ready"]);
          workOnScanQueue();
          workOnParseQueue();
        });
      }
    };
    (<any>self).Module = customModule;

    if (typeof importScripts === "function") {
      try {
        importScripts(`${libraryLocation}scandit-engine-sdk.min.js?v=%WASM_VERSION%`);
      } catch (error) {
        console.warn(error);
        console.error(
          `Couldn't retrieve Scandit SDK Engine library at ${libraryLocation}scandit-engine-sdk.min.js, ` +
            "did you configure the path for it correctly?"
        );
      }
    }
  }

  function createContext(): void {
    if (contextAvailable || licenseKey == null || !wasmLoaded) {
      return;
    }

    const licenseKeyLength: number = Module.lengthBytesUTF8(licenseKey) + 1;
    const licenseKeyPointer: number = Module._malloc(licenseKeyLength);
    Module.stringToUTF8(licenseKey, licenseKeyPointer, licenseKeyLength);
    Module.asm._create_context(licenseKeyPointer, false);
    Module._free(licenseKeyPointer);

    contextAvailable = true;
  }

  function setupSettings(highQualitySingleFrameMode: boolean = false): void {
    if (settings == null || !contextAvailable || !wasmLoaded) {
      return;
    }

    scannerSettingsReady = false;

    if (licenseKey == null) {
      console.error("No license key found, the library must be set up before the scanning engine can be used");

      return;
    }

    const parsedSettings: any = JSON.parse(settings);
    const settingsLength: number = Module.lengthBytesUTF8(settings) + 1;
    const settingsPointer: number = Module._malloc(settingsLength);
    Module.stringToUTF8(settings, settingsPointer, settingsLength);
    const resultPointer: number = Module.asm._scanner_settings_new_from_json(
      settingsPointer,
      blurryDecodingEnabled ? 1 : 0,
      parsedSettings.matrixScanEnabled ? 1 : 0,
      highQualitySingleFrameMode
    );
    Module._free(settingsPointer);

    const result: string = Module.UTF8ToString(resultPointer);
    if (result !== "") {
      scannerSettingsReady = true;
      postMessage(["status", "scan-settings-updated"]);
      console.debug(JSON.parse(result));
    }
  }

  function setupImageSettings(): void {
    if (imageSettings == null || !wasmLoaded) {
      return;
    }

    scannerImageSettingsReady = false;

    // We allocate for a grayscale image only as we will do a conversion here in the worker before passing it
    Module.asm._scanner_image_settings_new(imageSettings.width, imageSettings.height, 1);
    if (imageBufferPointer != null) {
      Module._free(imageBufferPointer);
      imageBufferPointer = undefined;
    }
    imageBufferPointer = Module._malloc(imageSettings.width * imageSettings.height);

    scannerImageSettingsReady = true;
  }

  function scanImage(imageData: Uint8ClampedArray): string {
    Module.HEAPU8.set(imageData, imageBufferPointer);

    return Module.UTF8ToString(Module.asm._scanner_scan(imageBufferPointer));
  }

  function parseString(dataFormat: Parser.DataFormat, dataString: string, options: string): string {
    const dataStringLength: number = Module.lengthBytesUTF8(dataString) + 1;
    const dataStringPointer: number = Module._malloc(dataStringLength);
    Module.stringToUTF8(dataString, dataStringPointer, dataStringLength);
    const optionsLength: number = Module.lengthBytesUTF8(options) + 1;
    const optionsPointer: number = Module._malloc(optionsLength);
    Module.stringToUTF8(options, optionsPointer, optionsLength);
    const resultPointer: number = Module.asm._parser_parse_string(
      dataFormat.valueOf(),
      dataStringPointer,
      dataStringLength - 1,
      optionsPointer
    );
    Module._free(dataStringPointer);
    Module._free(optionsPointer);

    return Module.UTF8ToString(resultPointer);
  }

  function workOnScanQueue(): void {
    if ((!scannerSettingsReady || !scannerImageSettingsReady) && scanQueue.length !== 0) {
      createContext();
      setupSettings();
      setupImageSettings();
    }

    if (!scannerSettingsReady || !scannerImageSettingsReady) {
      return;
    }

    let currentScanWorkUnit: ScanWorkUnit;
    let resultData: string;
    while (scanQueue.length !== 0) {
      currentScanWorkUnit = <ScanWorkUnit>scanQueue.shift();
      if (currentScanWorkUnit.highQualitySingleFrameMode) {
        setupSettings(true);
      }
      // TODO: For now it's not possible to use imported variables as the worker doesn't have access at runtime
      if (imageSettings.format.valueOf() === 1) {
        // RGB_8U
        resultData = scanImage(convertImageDataToGrayscale(currentScanWorkUnit.data, 3));
      } else if (imageSettings.format.valueOf() === 2) {
        // RGBA_8U
        resultData = scanImage(convertImageDataToGrayscale(currentScanWorkUnit.data, 4));
      } else {
        resultData = scanImage(currentScanWorkUnit.data);
      }
      if (currentScanWorkUnit.highQualitySingleFrameMode) {
        setupSettings(false);
      }
      const result: any = JSON.parse(resultData);
      if (result.error != null) {
        postMessage([
          "work-error",
          {
            requestId: currentScanWorkUnit.requestId,
            error: result.error
          }
        ]);
      } else if (result.scanResult != null) {
        postMessage([
          "work-result",
          {
            requestId: currentScanWorkUnit.requestId,
            result: result
          }
        ]);
      } else {
        console.error("Unrecognized Scandit Engine result:", result);
        postMessage([""], [currentScanWorkUnit.data.buffer]);
      }
    }
  }

  function workOnParseQueue(): void {
    if (!contextAvailable && parseQueue.length !== 0) {
      createContext();
    }

    if (!contextAvailable || !wasmLoaded) {
      return;
    }

    let currentParseWorkUnit: ParseWorkUnit;
    let resultData: string;
    while (parseQueue.length !== 0) {
      currentParseWorkUnit = <ParseWorkUnit>parseQueue.shift();
      resultData = parseString(
        currentParseWorkUnit.dataFormat,
        currentParseWorkUnit.dataString,
        currentParseWorkUnit.options
      );
      const result: any = JSON.parse(resultData);
      if (result.error != null) {
        postMessage([
          "parse-string-error",
          {
            requestId: currentParseWorkUnit.requestId,
            error: result.error
          }
        ]);
      } else if (result.result != null) {
        postMessage([
          "parse-string-result",
          {
            requestId: currentParseWorkUnit.requestId,
            result: result.result
          }
        ]);
      } else {
        console.error("Unrecognized Scandit Parser result:", result);
        postMessage([
          "parse-string-error",
          {
            requestId: currentParseWorkUnit.requestId,
            error: {
              errorCode: -1,
              errorMessage: "Unknown Scandit Parser error"
            }
          }
        ]);
      }
    }
  }

  function convertImageDataToGrayscale(imageData: Uint8ClampedArray, channels: number): Uint8ClampedArray {
    const grayscaleImageData: Uint8ClampedArray = new Uint8ClampedArray(imageData.length / channels);
    let grayscaleImageDataIndex: number = imageData.length / channels - 1;
    let imageDataIndex: number = imageData.length - channels;
    while (imageDataIndex >= 0) {
      grayscaleImageData[grayscaleImageDataIndex--] =
        imageData[imageDataIndex] * 0.299 +
        imageData[imageDataIndex + 1] * 0.587 +
        imageData[imageDataIndex + 2] * 0.114;
      imageDataIndex -= channels;
    }

    return grayscaleImageData;
  }

  onmessage = e => {
    // Setting settings triggers license verification and activation: delay until first frame processed
    const data: any = e.data;
    switch (data.type) {
      case "enable-blurry-decoding":
        blurryDecodingEnabled = true;
        if (scanWorkSubmitted) {
          setupSettings();
          workOnScanQueue();
        }
        break;
      case "load-library":
        loadLibrary(data.deviceId, data.libraryLocation);
        (<any>self).path = data.path; // Used by the Internal Scandit Engine
        break;
      case "license-key":
        licenseKey = data.licenseKey;
        createContext();
        if (parseWorkSubmitted) {
          workOnParseQueue();
        }
        break;
      case "settings":
        settings = data.settings;
        if (scanWorkSubmitted) {
          setupSettings();
          workOnScanQueue();
        }
        break;
      case "image-settings":
        imageSettings = data.imageSettings;
        if (scanWorkSubmitted) {
          setupImageSettings();
          workOnScanQueue();
        }
        break;
      case "work":
        scanWorkSubmitted = true;
        scanQueue.push({
          requestId: data.requestId,
          data: data.data,
          highQualitySingleFrameMode: data.highQualitySingleFrameMode
        });
        workOnScanQueue();
        break;
      case "parse-string":
        parseWorkSubmitted = true;
        parseQueue.push({
          requestId: data.requestId,
          dataFormat: data.dataFormat,
          dataString: data.dataString,
          options: data.options
        });
        workOnParseQueue();
        break;
      default:
        break;
    }
  };
}

/**
 * @hidden
 */
export const engineSDKWorker: Blob = new Blob([`(${engineSDKWorkerFunction.toString()})()`], {
  type: "text/javascript"
});
